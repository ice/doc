<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="stylesheet" type="text/css" href="../../asset/static/css/bootstrap.min.css" />
        <link rel="stylesheet" type="text/css" href="../../asset/static/css/tomorrow.min.css" id="tomorrow" />
        <link rel="stylesheet" type="text/css" href="../../asset/static/css/tomorrow-night.min.css" id="tomorrow-night" disabled />
        <link rel="stylesheet" type="text/css" href="../../asset/static/css/style.css" />
    </head>
    <body>
        <header class="navbar navbar-default navbar-fixed-top">
            <div id="top-bar" class="container-fluid">
                <div id="top-left" class="navbar-header">
                    <a href="../../index.html" class="navbar-brand">
                                                    ice Documentation <span class="version">v1.0.31</span>
                                            </a>
                </div>
                <div id="top-right" class="collapse navbar-collapse">

                </div>
            </div>
        </header>
        <div id="body" class="container-fluid">
            <div class="row">
                <div id="body-left" class="col-lg-3 col-sm-4">
                    <div class="header-search">
                        <input class="search-box form-control" placeholder="Search for a class or namespace " type="text" />
                        <div id="menu-wrapper">
                        </div>
                    </div>
                </div>
                <div id="body-right" class="col-lg-9 col-sm-8">
                    <div class="content">
                        
<div>
    
    <ul class="breadcrumb">
        
        <li><a href="../../index.html">Home</a></li>
        
                <li><a href="../../classes.html">Classes</a></li>
                <li><a href="../../class/Ice/Validation.html">Ice\Validation</a></li>
                <li><a >Source</a></li>
                
    </ul>
    
</div>
<div class="class-header source clearfix">
    
    <div class="access-buttons pull-right">
        <a class="zep-button btn btn-default" href="../../class/Ice/Validation.html">Class</a>

                <a class="zep-button btn btn-default" href="https://github.com/ice/framework/tree/dev/ice/validation.zep">Github</a>
            </div>
    
    <div class="class-full-name">
        
        <span class="class-type">Class</span>
        
                <span class="namespace-piece">
            <a href="../../namespace/Ice.html">Ice</a>
        </span>
                <h1 class="class-name">Validation</h1>
    </div>
    
</div>


<pre class="zephir-source-file"><code>
namespace Ice;

use Ice\Validation\Validator;

/**
 * Allows to validate array data.
 *
 * @package     Ice/Validation
 * @category    Security
 * @author      Ice Team
 * @copyright   (c) 2014-2015 Ice Team
 * @license     http://iceframework.org/license
 * @uses        Ice\Filter (if service is available)
 * @uses        Ice\I18n (if service is available)
 *
 * &lt;pre&gt;&lt;code&gt;
 *  $validation = new Ice\Validation();
 *  
 *  $validation-&gt;rules([
 *      &apos;fullName&apos; =&gt; &apos;required&apos;,
 *      &apos;email&apos; =&gt; &apos;required|email&apos;,
 *      &apos;repeatEmail&apos; =&gt; &apos;same:email&apos;,
 *      &apos;about&apos; =&gt; &apos;required|length:10,5000&apos;,
 *  ]);
 *  
 *  $valid = $validation-&gt;validate($_POST);
 *  
 *  if (!$valid) {
 *      $messages = $validation-&gt;getMessages();
 *  }
 * &lt;/code&gt;&lt;/pre&gt;
 */
class Validation
{

    protected di { get };
    protected data = [];
    protected rules = [] { set, get };
    protected validators = [];
    protected filters = [] { set };
    protected labels = [] { set };
    protected messages = [];
    protected valid = true;
    protected aliases = [] { set };
    protected translate = true { set, get };
    protected humanLabels = false { set };
    protected defaultMessages = [
        &quot;alnum&quot;: &quot;Field :field must contain only letters and numbers&quot;,
        &quot;alpha&quot;: &quot;Field :field must contain only letters&quot;,
        &quot;between&quot;: &quot;Field :field must be within the range of :min to :max&quot;,
        &quot;digit&quot;: &quot;Field :field must be numeric&quot;,
        &quot;default&quot;: &quot;Field :field is not valid&quot;,
        &quot;email&quot;: &quot;Field :field must be an email address&quot;,
        &quot;fileEmpty&quot;: &quot;Field :field must not be empty&quot;,
        &quot;fileIniSize&quot;: &quot;File :field exceeds the maximum file size&quot;,
        &quot;fileMaxResolution&quot;: &quot;File :field must not exceed :max resolution&quot;,
        &quot;fileMinResolution&quot;: &quot;File :field must be at least :min resolution&quot;,
        &quot;fileSize&quot;: &quot;File :field exceeds the size of :max&quot;,
        &quot;fileType&quot;: &quot;File :field must be of type: :types&quot;,
        &quot;in&quot;: &quot;Field :field must be a part of list: :values&quot;,
        &quot;lengthMax&quot;: &quot;Field :field must not exceed :max characters long&quot;,
        &quot;lengthMin&quot;: &quot;Field :field must be at least :min characters long&quot;,
        &quot;notIn&quot;: &quot;Field :field must not be a part of list: :values&quot;,
        &quot;regex&quot;: &quot;Field :field does not match the required format&quot;,
        &quot;required&quot;: &quot;Field :field is required&quot;,
        &quot;same&quot;: &quot;Field :field and :other must match&quot;,
        &quot;unique&quot;: &quot;Field :field must be unique&quot;,
        &quot;url&quot;: &quot;Field :field must be a url&quot;,
        &quot;with&quot;: &quot;Field :field must occur together with :fields&quot;,
        &quot;without&quot;: &quot;Field :field must not occur together with :fields&quot;
    ];

    /**
     * Validation constructor. Fetch Di and set the data if given.
     *
     * @param array data Data to validate
     */
    public function __construct(array data = [])
    {
        let this-&gt;di = Di::$fetch(),
            this-&gt;data = data;
    }

    /**
     * Resolve one rule.
     *
     * @param string alias
     * @param string field
     * @param mixed options
     * @return void
     */
    public function resolve(string alias, string field, var options = null) -&gt; void
    {
        var rule;

        if !fetch rule, this-&gt;aliases[alias] {
            let rule = &quot;Ice\\Validation\\Validator\\&quot; . camelize(alias);

            if !class_exists(rule) {
                throw new Exception(sprintf(&quot;Validator %s not found&quot;, alias));
            }
        }

        let this-&gt;rules[field][] = &lt;Validator&gt; create_instance_params(rule, [options]);
    }

    /**
     * Add one rule.
     *
     * &lt;pre&gt;&lt;code&gt;
     *  $validation = new Ice\Validation();
     *  
     *  $validation-&gt;rule(&apos;email&apos;, &apos;required|email&apos;);
     *  $validation-&gt;rule(&apos;content&apos;, [
     *      &apos;length&apos; =&gt; [
     *          &apos;max&apos; =&gt; 1000,
     *          &apos;messageMin&apos; =&gt; &apos;Too long!&apos;,
     *          &apos;label&apos; =&gt; &apos;Desctiption&apos;
     *      ]
     *  ]);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param string field
     * @param mixed validators
     * @param mixed options
     * @return void
     */
    public function rule(string field, var validators, var options = null) -&gt; void
    {
        var validator, rules, rule, alias, values;

        switch typeof validators {
            case &quot;object&quot;:
                let this-&gt;rules[field][] = &lt;Validator&gt; validators;
            break;
            case &quot;array&quot;:
                for validator, options in validators {
                    if typeof validator == &quot;integer&quot; {
                        let validator = options;
                    }
                    this-&gt;rule(field, validator, options);
                }
            break;
            case &quot;string&quot;:
                if strpos(validators, &quot;|&quot;) === false &amp;&amp; strpos(validators, &quot;:&quot;) === false {
                    this-&gt;resolve(validators, field, options);
                } else {
                    let rules = explode(&quot;|&quot;, validators);

                    for rule in rules {
                        let options = explode(&quot;:&quot;, rule),
                            alias = array_shift(options);

                        if alias != &quot;regex&quot; {
                            if fetch values, options[0] {
                                let options = explode(&quot;,&quot;, values);
                            }
                        }

                        this-&gt;resolve(alias, field, options);
                    }
                }
            break;
        }
    }

    /**
     * Add multiple rules at once.
     *
     * &lt;pre&gt;&lt;code&gt;
     *  $validation = new Ice\Validation();
     *  
     *  $validation-&gt;rules([
     *      &apos;username&apos; =&gt; &apos;required|length:4,24|notIn:admin,user,root|unique:users&apos;,
     *      &apos;password&apos;  =&gt; &apos;required|length:5,32&apos;,
     *      &apos;repeatPassword&apos;  =&gt; &apos;same:password&apos;,
     *      &apos;email&apos;  =&gt; &apos;email&apos;,
     *      &apos;status&apos;  =&gt; &apos;required|digit|in:0,1,2&apos;,
     *      &apos;website&apos;  =&gt; &apos;url&apos;,
     *      &apos;title&apos;  =&gt; &apos;length:,100&apos;,
     *      &apos;age&apos;  =&gt; &apos;required|between:18,21&apos;,
     *  ]);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param array validators
     * @return void
     */
    public function rules(array! validators) -&gt; void
    {
        var field, rules;

        for field, rules in validators {
            this-&gt;rule(field, rules);
        }
    }

    /**
     * Validate the data.
     *
     * @param array data Data to validate
     * @return boolean
     */
    public function validate(array data = []) -&gt; boolean
    {
        var field, rules, rule;

        if count(data) {
            let this-&gt;data = data;
        }

        // Validate the rules
        for field, rules in this-&gt;rules {
            for rule in rules {
                if rule-&gt;validate(this, field)  === false {
                    let this-&gt;valid = false;
                }
            }
        }

        // Double check
        if count(this-&gt;messages) {
            let this-&gt;valid = false;
        }

        return this-&gt;valid;
    }

    /**
     * Check if validation passed.
     *
     * @return boolean
     */
    public function valid() -&gt; boolean
    {
        return this-&gt;valid;
    }

    /**
     * Whether or not a value exists by field.
     *
     * @param string field The data key
     * @return boolean
     */
    public function hasValue(string! field) -&gt; boolean
    {
        return isset this-&gt;data[field];
    }

    /**
     * Get a value by field.
     *
     * @param string field The data key
     * @param boolean filtered Get the filtered value or original
     * @return mixed
     */
    public function getValue(string! field, boolean filtered = true)
    {
        var value, filters;

        fetch value, this-&gt;data[field];

        // Filter the value
        if filtered &amp;&amp; this-&gt;di-&gt;has(&quot;filter&quot;) &amp;&amp; fetch filters, this-&gt;filters[field] {
            let value = this-&gt;di-&gt;get(&quot;filter&quot;)-&gt;sanitize(value, filters);
        }

        return value;
    }

    /**
     * Get the values by fields.
     * Values are automatically filtered out if filters have been setted.
     * 
     * &lt;pre&gt;&lt;code&gt;
     *  // Get value for one field
     *  $validation-&gt;getValues(&apos;password&apos;);
     *  
     *  // Get values for multiple fields
     *  $validation-&gt;getValues([&apos;fullName&apos;, &apos;about&apos;]);
     *  
     *  // Get all values
     *  $validation-&gt;getValues();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param mixed fields The data keys
     * @param boolean filtered Get the filtered value or original
     * @return mixed
     */
    public function getValues(var fields = null, boolean filtered = true)
    {
        var data, field;

        let data = [];

        if fields === null {
            for field, _ in this-&gt;data {
                let data[field] = this-&gt;getValue(field, filtered);
            }
        } else {
            switch typeof fields {
                case &quot;array&quot;:
                    for field in fields {
                        if isset this-&gt;data[field] {
                            let data[field] = this-&gt;getValue(field, filtered);
                        }
                    }
                break;
                case &quot;string&quot;:
                    let data = this-&gt;getValue(fields, filtered);
                break;
            }
        }
            
        return data;
    }

    /**
     * Get the label of a field.
     * Humanize a label if humanLabels attribute and filter service is available
     *
     * @param string field The data key
     * @return string
     */
    public function getLabel(string! field) -&gt; string
    {
        var label;

        if !fetch label, this-&gt;labels[field] {
            // Humanize the field
            if this-&gt;humanLabels &amp;&amp; this-&gt;di-&gt;has(&quot;filter&quot;) {
                let label = this-&gt;di-&gt;get(&quot;filter&quot;)-&gt;sanitize(field, &quot;human&quot;);
            } else {
                let label = field;
            }
        }

        return label;
    }

    /**
     * Set the default messages.
     *
     * @param array messages
     * @return void
     */
    public function setDefaultMessages(array messages = []) -&gt; void
    {
        let this-&gt;defaultMessages = array_merge(this-&gt;defaultMessages, messages);
    }

    /**
     * Get a default message for the type.
     *
     * @param string type Type of message
     * @return string
     */
    public function getDefaultMessage(string! type) -&gt; string
    {
        var message;

        if !fetch message, this-&gt;defaultMessages[type] {
            let message = this-&gt;defaultMessages[&quot;default&quot;];
        }

        return message;
    }

    /**
     * Add a message to the field.
     *
     * @param string field
     * @param string message
     * @return void
     */
    public function addMessage(string! field, string message) -&gt; void
    {
        let this-&gt;messages[field][] = message;
    }

    /**
     * Get the validation&apos;s messages.
     *
     * @return Arr
     */
    public function getMessages() -&gt; &lt;Arr&gt;
    {
        return new Arr(this-&gt;messages);
    }
}
</code></pre>                    </div>
                </div>
            </div>
        </div>

        <script src="../../asset/static/js/jquery.min.js"></script>
        <script src="../../asset/static/js/bootstrap.min.js"></script>
        <script src="../../asset/static/js/highlight.pack.js"></script>
        <script src="../../asset/static/js/jquery.slimscroll.min.js"></script>
        <script src="../../asset/api_definition.js"></script>

        <script>var ZepCurrentPath = '../../'</script>
        <script src="../../asset/static/js/script.js"></script>
        <script type="text/javascript">
            $(window).on("load resize", function() {
                $('#menu-wrapper').slimscroll({ height: $(window).height() - 100, size: '3px' });
            });
        </script>
        <script type="text/javascript">
            $(document).ready(function() { $('pre code').each(function(i, block) { hljs.highlightBlock(block); }); });
            if ($('.zephir-source-file').length) {
                $('link[id]').each(function(i, link) {
                    link.disabled = (link.id != 'tomorrow-night');
                });
            }
        </script>
            </body>
</html>