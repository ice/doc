<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="stylesheet" type="text/css" href="../../../../../../asset/static/css/bootstrap.min.css" />
        <link rel="stylesheet" type="text/css" href="../../../../../../asset/static/css/tomorrow.min.css" id="tomorrow" />
        <link rel="stylesheet" type="text/css" href="../../../../../../asset/static/css/tomorrow-night.min.css" id="tomorrow-night" disabled />
        <link rel="stylesheet" type="text/css" href="../../../../../../asset/static/css/style.css" />
    </head>
    <body>
        <header class="navbar navbar-default navbar-fixed-top">
            <div id="top-bar" class="container-fluid">
                <div id="top-left" class="navbar-header">
                    <a href="../../../../../../index.html" class="navbar-brand">
                        Ice Documentation <span class="version">1.0.0</span>
                    </a>
                </div>
                <div id="top-right" class="collapse navbar-collapse">

                </div>
            </div>
        </header>
        <div id="body" class="container-fluid">
            <div class="row">
                <div id="body-left" class="col-lg-3 col-sm-4">
                    <div class="header-search">
                        <input class="search-box form-control" placeholder="Search for a class or namespace " type="text" />
                        <div id="menu-wrapper">
                        </div>
                    </div>
                </div>
                <div id="body-right" class="col-lg-9 col-sm-8">
                    <div class="content">
                        
<div>
    
    <ul class="breadcrumb">
        
        <li><a href="../../../../../../index.html">Home</a></li>
        
                <li><a href="../../../../../../classes.html">Classes</a></li>
                <li><a href="../../../../../../class/Ice/Mvc/View/Engine/Sleet/Parser.html">Ice\Mvc\View\Engine\Sleet\Parser</a></li>
                <li><a >Source</a></li>
                
    </ul>
    
</div>
<div class="class-header source clearfix">
    
    <div class="access-buttons pull-right">
        <a class="zep-button btn btn-default" href="../../../../../../class/Ice/Mvc/View/Engine/Sleet/Parser.html">Class</a>

                <a class="zep-button btn btn-default" href="https://github.com/ice/framework/tree/dev/ice/mvc/view/engine/sleet/parser.zep">Github</a>
            </div>
    
    <div class="class-full-name">
        
        <span class="class-type">Class</span>
        
                <span class="namespace-piece">
            <a href="../../../../../../namespace/Ice.html">Ice</a>
        </span>
                <span class="namespace-piece">
            <a href="../../../../../../namespace/Ice/Mvc.html">Mvc</a>
        </span>
                <span class="namespace-piece">
            <a href="../../../../../../namespace/Ice/Mvc/View.html">View</a>
        </span>
                <span class="namespace-piece">
            <a href="../../../../../../namespace/Ice/Mvc/View/Engine.html">Engine</a>
        </span>
                <span class="namespace-piece">
            <a href="../../../../../../namespace/Ice/Mvc/View/Engine/Sleet.html">Sleet</a>
        </span>
                <h1 class="class-name">Parser</h1>
    </div>
    
</div>


<pre class="zephir-source-file"><code>
namespace Ice\Mvc\View\Engine\Sleet;

use Ice\Exception;

/**
 * Sleet file parser.
 *
 * @package     Ice/View
 * @category    Component
 * @author      Ice Team
 * @copyright   (c) 2014-2015 Ice Team
 * @license     http://iceframework.org/license
 */
class Parser
{

    protected _functions = [
        "content": "$this->getContent",
        "partial": "$this->partial",
        "load": "$this->load",
        "dump": "$this->dump->vars",
        "version": "Ice\\Version::get"
    ];

    protected _filters = [
        "capitalize": "ucfirst"
    ];

    protected _env = [];

    const NORMAL = 0;
    const SHORTIF = 1;
    const INARRAY = 2;

    /**
     * Sleet parser constructor. Fetch Ice\Tag methods.
     */
    public function __construct()
    {
        var tag, methods, functions, method;

        let tag = new \ReflectionClass("Ice\\Tag"),
            methods = tag->getMethods(\ReflectionMethod::IS_PUBLIC),
            functions = [];

        for method in methods {
            switch method->name {
                case "__construct":
                    continue;
                default:
                    let functions[method->name] = "$this->tag->" . method->name,
                        functions[uncamelize(method->name)] = "$this->tag->" . method->name;
            }
        }

        let this->_functions = array_merge(this->_functions, functions),
            this->_env[] = Parser::NORMAL;
    }

    /**
     * Parse text, line by line.
     *
     * @param string text
     * @return string Parsed text
     */
    public function text(string text) -> string
    {
        var parsed, key, line;

        let parsed = "";

        for key, line in explode(PHP_EOL, text) {
            let parsed .= (key ? PHP_EOL : "") . this->line(line, key + 1);
        }
        return parsed;
    }

    /**
     * Parse one line - detect the expressions.
     *
     * @param string line
     * @param int no Line number
     * @return string Parsed line
     */
    public function line(string line, int no = 1) -> string
    {
        var pos, start, parsedLine, end, ch;
        int i;

        let pos = 0,
            start = strpos(line, "{"),
            parsedLine = "";

        while start !== false {
            let i = start + 1,
                ch = line[i];

            switch ch {
                case '{':
                    // append string before tokens, search close-symbol of the tag
                    let parsedLine .= substr(line, pos, (int) (start - pos)),
                        end = strpos(line, "}}", start + 2);

                    if end === false {
                        // If unexpected end of template
                        throw new Exception(sprintf("Unclosed tag on the line %d", no + 1));
                    }

                    let end = end + 2,
                        parsedLine .= this->parse(substr(line, start, (int) (end - start)));
                break;
                case '%':
                    // append string before tokens, search close-symbol of the tag
                    let parsedLine .= substr(line, pos, (int) (start - pos)),
                        end = strpos(line, "%}", start + 2);
                   
                    if end === false {
                        // If unexpected end of template
                        throw new Exception(sprintf("Unclosed tag on the line %d", no + 1));
                    }

                    let end = end + 2,
                        parsedLine .= this->parse(substr(line, start, (int) (end - start)));
                break;
                case '#':
                    // append string before comment, search close-symbol of the comment
                    let parsedLine .= substr(line, pos, (int) (start - pos)),
                        end = strpos(line, "#}", start + 2);
                   
                    if end === false {
                        // If unexpected end of template
                        throw new Exception(sprintf("Unclosed comment block on the line %d", no + 1));
                    }

                    let end = end + 2;
                break;
                default:
                    // Ignore the tag
                    let parsedLine .= substr(line, pos, (int) (start - pos + 1)),
                        end = start + 1;
                break;
            }
            // next tokens
            let pos = end,
                start = strpos(line, "{", pos);
        }
        // append string after tokens
        let parsedLine .= substr(line, pos);

        return parsedLine;
    }

    /**
     * Parse one sleet expression.
     *
     * @param string expression
     * @return string
     */
    public function parse(string expression) -> string
    {
        var php, tokenized, tokens, token, first;

        if starts_with(expression, "{{") {
            let php = "<?php echo " . substr(expression, 2, -2);
        } else {
            let php = "<?php " . substr(expression, 2, -2);
        }

        let tokenized = token_get_all(php),
            tokens = [];

        array_shift(tokenized);

        for token in tokenized {
            if typeof token == "array" && token[0] == T_WHITESPACE {
                continue;
            }
            let tokens [] = token;
        }

        let first = array_shift(tokens);

        if typeof first != "array" {
            throw new Exception("Unexpected first tag");
        }

        if typeof tokens != "array" {
            throw new Exception("Unexpected expression");
        }

        switch first[0] {
            case T_ENDIF:
            case T_ENDFOR:
            case T_ENDWHILE:
            case T_ENDSWITCH:
            case T_ENDFOREACH:
                return "<?php " . first[1] . " ?>";
            case T_BREAK:
                return "<?php " . first[1] . "; ?>";
            case T_ELSE:
            case T_DEFAULT:
                return "<?php " . first[1] . ": ?>";
            case T_SWITCH:
            case T_CASE:
            case T_IF:
            case T_ELSEIF:
            case T_DO:
            case T_FOR:
            case T_WHILE:
            case T_FOREACH:
                return this->parseControl(first[1], tokens);
            case T_ECHO:
                return this->parseEcho(tokens);
            case T_VAR:
                return this->parseSet(tokens);
            case T_STRING:
                if first[1] == "set" {
                    return this->parseSet(tokens);
                }
                break;
            case T_USE:
                return this->parseUse(tokens);
        }
        return "";
    }

    /**
     * Parse control expression.
     *
     * @param string control Control structure
     * @param array expression Tokens
     * @return string
     */
    private function parseControl(control, expression) -> string
    {
        return "<?php " . control . "(" . this->_parse(expression) . "): ?>";
    }
    
    /**
     * Parse echo expression.
     *
     * @param array expression Tokens
     * @return string
     */
    private function parseEcho($expression) -> string
    {
        return "<?php echo " . this->_parse(expression) . " ?>";
    }

    /**
     * Parse set expression.
     *
     * @param array expression Tokens
     * @return string
     */
    private function parseSet($expression) -> string
    {
        return "<?php " . this->_parse(expression) . "; ?>";
    }

    /**
     * Parse use expression.
     *
     * @param array expression Tokens
     * @return string
     */
    private function parseUse($expression) -> string
    {
        return "<?php use " . this->_parse(expression) . "; ?>";
    }

    /**
     * Internal tokens parse.
     *
     * @param array tokens
     * @return string
     */
    private function _parse(tokens) -> string
    {
        var i, parsed, prev, next, token, filter, seek, filters;

        let i = new \ArrayIterator(tokens),
            parsed = "",
            prev = "";

        while i->valid() {
            let token = i->current(),
                next = i->offsetExists(i->key() + 1) ? i->offsetGet(i->key() + 1) : null;

            if next == "|" {
                let seek = i->key() + 2,
                    filter = i->offsetGet(seek),
                    filter = isset this->_filters[filter[1]] ? this->_filters[filter[1]] : filter[1],
                    filters = ["camelize", "uncamelize", "human", "lower", "upper", "alnum", "alpha", "email", "float", "int", "string", "strip_repeats", "e", "escape", "strip_special", "unescape", "unstrip_special"];

                if in_array(filter, filters) {
                    let parsed .=  "$this->filter->sanitize(" . this->_token(token, prev, next) . ", '" . filter . "'";
                } else {
                    let parsed .= filter . "(" . this->_token(token, prev, next);
                }
                
                let next = i->offsetExists(seek + 1) ? i->offsetGet(seek + 1) : null;

                if next == "(" {
                    let parsed .= ", ",
                        seek++;
                } else {
                    let parsed .= ")";
                }

                i->seek(seek);
                i->next();
                continue;
            }
            
            let parsed .= this->_token(token, prev, next),
                prev = token;

            i->next();
        }
        return parsed;
    }

    /**
     * Internal token parse.
     *
     * @param mixed token
     * @param mixed prev
     * @param mixed next
     * @return mixed
     */
    private function _token(token, prev = null, next = null)
    {
        string str;

        if typeof token == "array" {
            switch token[0] {
                case T_AS:
                case T_IS_EQUAL:
                case T_IS_NOT_EQUAL:
                case T_IS_IDENTICAL:
                case T_IS_NOT_IDENTICAL:
                case T_IS_SMALLER_OR_EQUAL:
                case T_IS_GREATER_OR_EQUAL:
                    return " " . token[1] . " ";
                case T_LOGICAL_OR:
                    return " || ";
                case T_LOGICAL_AND:
                    return " && ";
                case T_STRING:
                    let str = (string) token[1];

                    if next == "(" && (prev != "." || typeof prev == "array" && prev[0] != T_DOUBLE_COLON) {
                        return isset this->_functions[str] ? this->_functions[str] : str;
                    }
                    switch str {
                        case "in":
                            return " as ";
                        case "is":
                            return next == "!" ? " != " : " == ";
                        case "and":
                            return " && ";
                        case "or":
                            return " || ";
                        case "not":
                            return "!";
                        case "false":
                        case "true":
                        case "null":
                            return str;
                        default:
                            if prev == "." || next == "(" || ctype_upper(str[0]) && next != "|" {
                                return str;
                            }
                            return "$" . str;
                    }
                default:
                    return token[1];
            }
        } else {
            switch token {
                case "-":
                case "+": 
                case "*": 
                case "/": 
                case "%": 
                case "=": 
                case ">": 
                case "<": 
                    return " " . token . " ";
                case "~":
                    return " . ";
                case ",":
                    return ", ";
                case ".":
                    return "->";
                case ":":
                    switch end(this->_env) {
                        case Parser::SHORTIF:
                            array_pop(this->_env);
                            return " : ";
                        default:
                            return " => ";
                    }
                case "?":
                    let this->_env[] = Parser::SHORTIF;
                    return " ? ";
                case "[":
                    let this->_env[] = Parser::INARRAY;
                    return token;
                case "]":
                    if end(this->_env) == Parser::INARRAY {
                        array_pop(this->_env);
                    }
                    return token;
                default:
                    return token;
            }
        }
    }
}
</code></pre>                    </div>
                </div>
            </div>
        </div>

        <script src="../../../../../../asset/static/js/jquery.min.js"></script>
        <script src="../../../../../../asset/static/js/bootstrap.min.js"></script>
        <script src="../../../../../../asset/static/js/highlight.pack.js"></script>
        <script src="../../../../../../asset/static/js/jquery.slimscroll.min.js"></script>
        <script src="../../../../../../asset/api_definition.js"></script>

        <script>var ZepCurrentPath = '../../../../../../'</script>
        <script src="../../../../../../asset/static/js/script.js"></script>
        <script type="text/javascript">
            $(window).on("load resize", function() {
                $('#menu-wrapper').slimscroll({ height: $(window).height(), size: '3px' });
            });
        </script>
        <script type="text/javascript">
            $(document).ready(function() { $('pre code').each(function(i, block) { hljs.highlightBlock(block); }); });
            if ($('.zephir-source-file').length) {
                $('link[id]').each(function(i, link) {
                    link.disabled = (link.id != 'tomorrow-night');
                });
            }
        </script>
            </body>
</html>