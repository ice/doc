<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="stylesheet" type="text/css" href="../../../asset/static/css/bootstrap.min.css" />
        <link rel="stylesheet" type="text/css" href="../../../asset/static/css/tomorrow.min.css" id="tomorrow" />
        <link rel="stylesheet" type="text/css" href="../../../asset/static/css/tomorrow-night.min.css" id="tomorrow-night" disabled />
        <link rel="stylesheet" type="text/css" href="../../../asset/static/css/style.css" />
    </head>
    <body>
        <header class="navbar navbar-default navbar-fixed-top">
            <div id="top-bar" class="container-fluid">
                <div id="top-left" class="navbar-header">
                    <a href="../../../index.html" class="navbar-brand">
                                                    ice Documentation <span class="version">v1.4.0</span>
                                            </a>
                </div>
                <div id="top-right" class="collapse navbar-collapse">

                </div>
            </div>
        </header>
        <div id="body" class="container-fluid">
            <div class="row">
                <div id="body-left" class="col-lg-3 col-sm-4">
                    <div class="header-search">
                        <input class="search-box form-control" placeholder="Search for a class or namespace " type="text" />
                        <div id="menu-wrapper">
                        </div>
                    </div>
                </div>
                <div id="body-right" class="col-lg-9 col-sm-8">
                    <div class="content">
                        
<div>
    
    <ul class="breadcrumb">
        
        <li><a href="../../../index.html">Home</a></li>
        
                <li><a href="../../../classes.html">Classes</a></li>
                <li><a href="../../../class/Ice/Http/Response.html">Ice\Http\Response</a></li>
                <li><a >Source</a></li>
                
    </ul>
    
</div>
<div class="class-header source clearfix">
    
    <div class="access-buttons pull-right">
        <a class="zep-button btn btn-default" href="../../../class/Ice/Http/Response.html">Class</a>

                <a class="zep-button btn btn-default" href="https://github.com/ice/framework/tree/dev/ice/http/response.zep">Github</a>
            </div>
    
    <div class="class-full-name">
        
        <span class="class-type">Class</span>
        
                <span class="namespace-piece">
            <a href="../../../namespace/Ice.html">Ice</a>
        </span>
                <span class="namespace-piece">
            <a href="../../../namespace/Ice/Http.html">Http</a>
        </span>
                <h1 class="class-name">Response</h1>
    </div>
    
</div>


<pre class="zephir-source-file"><code>
namespace Ice\Http;

use Ice\Di;
use Ice\Exception;
use Ice\Http\Response\Headers;
use Ice\Http\Request\RequestInterface;
use Ice\Http\Response\ResponseInterface;

/**
 * This class provides a simple interface around the HTTP response.
 *
 * @package     Ice/Http
 * @category    Component
 * @author      Ice Team
 * @copyright   (c) 2014-2018 Ice Team
 * @license     http://iceframework.org/license
 */
class Response implements ResponseInterface
{

    protected protocolVersion = &quot;HTTP/1.1&quot; { get, set };
    protected status = 200 { get, set };
    protected headers;
    protected loops = 16 { get, set };
    protected redirects = 0 { get };
    protected body { get, set };

    /**
     * Response constructor. Fetch Di and set it as a property.
     *
     * @param string|null body The HTTP response body
     * @param int status The HTTP response status
     */
    public function __construct(var body = null, int status = 200)
    {
        let this-&gt;headers = new Headers(),
            this-&gt;status = status,
            this-&gt;body = body;

        this-&gt;headers-&gt;set(&quot;Content-Type&quot;, &quot;text/html&quot;);
    }

    /**
     * Get HTTP headers.
     *
     * @return array
     */
    public function getHeaders() -&gt; array
    {
        return this-&gt;headers-&gt;all();
    }

    /**
     * Check whether request have a given header.
     *
     * @param string name
     * @return boolean
     */
    public function hasHeader(string name) -&gt; boolean
    {
        return this-&gt;headers-&gt;has(name);
    }

    /**
     * Get header value.
     *
     * @param string name
     * @return string
     */
    public function getHeader(string name) -&gt; string
    {
        return this-&gt;headers-&gt;get(name);
    }

    /**
     * Set header value.
     *
     * @param string name
     * @param string value
     * @return object Response
     */
    public function setHeader(string name, string value)
    {
        this-&gt;headers-&gt;set(name, value);
        
        return this;
    }

    /**
     * Set multiple header values.
     *
     * @param array headers
     * @return object Response
     */
    public function setHeaders(array headers)
    {
        this-&gt;headers-&gt;replace(headers);
        
        return this;
    }

    /**
     * Remove header by index name.
     *
     * @param string name
     * @return object Response     
     */
    public function removeHeader(string name)
    {
        this-&gt;headers-&gt;remove(name);
        
        return this;
    }

    /**
     * Set body content.
     *
     * @param string content
     * @return object Response
     */
    public function setContent(string contet) -&gt; object
    {
        let this-&gt;body = contet;

        return this;
    }

    /**
     * Finalize response for delivery to client.
     * Apply final preparations to the resposne object so that it is suitable for delivery to the client.
     *
     * @param RequestInterface request
     * @return object Response
     */
    public function finalize(&lt;RequestInterface&gt; request)
    {
        var sendBody;

        let sendBody = true;

        if in_array(this-&gt;status, [204, 304]) {
            this-&gt;headers-&gt;remove(&quot;Content-Type&quot;);
            this-&gt;headers-&gt;remove(&quot;Content-Length&quot;);
            let sendBody = false;
        }

        // Remove body if HEAD request
        if request-&gt;isHead() {
            let sendBody = false;
        }

        // Truncate body if it should not be sent with response
        if !sendBody {
            let this-&gt;body = &quot;&quot;;
        }

        return this;
    }

    /**
     * Send HTTP response headers.
     *
     * @return object Response
     */
    public function send()
    {
        if !headers_sent() {
            if strpos(PHP_SAPI, &quot;cgi&quot;) === 0 {
                header(sprintf(&quot;Status: %d %s&quot;, this-&gt;status, this-&gt;getMessage(this-&gt;status)));
            } else {
                header(sprintf(&quot;%s %d %s&quot;, this-&gt;getProtocolVersion(), this-&gt;status, this-&gt;getMessage(this-&gt;status)));
            }

            var di = Di::$fetch();

            if di-&gt;has(&quot;session&quot;) &amp;&amp; !this-&gt;isRedirect() {
                di-&gt;get(&quot;session&quot;)-&gt;remove(&quot;_redirects&quot;);
            }

            this-&gt;headers-&gt;send();
        }

        return this;
    }

    /**
     * Send file download as the response. All execution will be halted when
     * this method is called! The third parameter allows the following
     * options to be set:
     *
     * Type      | Option    | Description                        | Default Value
     * ----------|-----------|------------------------------------|--------------
     * string    | file      | file that already exists           | null
     * boolean   | inline    | Display inline instead of download | FALSE
     * boolean   | resumable | Allow to resumable download        | FALSE
     * boolean   | delete    | Delete the file after sending      | FALSE
     * int       | timeout   | Execute time for the script        | 0
     * int       | speed     | Download speed in millisecond      | 0
     *
     * Download a file that already exists:
     *
     *     $request-&gt;sendFile(&apos;ice.zip&apos;, &apos;application/zip&apos;, [&apos;file&apos; =&gt; &apos;/download/latest.zip&apos;]);
     *
     * Download generated content as a file:
     *
     *     $response-&gt;setContent($content);
     *     $response-&gt;sendFile($filename, $mineType);
     *
     * Attention: No further processing can be done after this method is called!
     *
     * @param string filename The file name of the attachment
     * @param string mime Manual mime type
     * @param array options The keys can be [file|inline|resumable|delete|timeout|speed]
     * @return  void
     */
    public function sendFile(string filename, string mime, array options = [])
    {
        var file, filepath, data, size, isDelete, disposition, block, pos, speed, range, start, end;

        if empty options[&quot;file&quot;] {
            // Force the data to be rendered if
            let data = (string) this-&gt;body;

            // Get the content size
            let size = strlen(data);

            // Create a temporary file to hold the current response
            let file = tmpfile();

            // Write the current response into the file
            fwrite(file, data);

            let isDelete = false;
        } else {
            // Get the complete file path
            let filepath = realpath(options[&quot;file&quot;]);

            // Get the file size
            let size = filesize(filepath);

            // Open the file for reading
            let file = fopen(filepath, &quot;rb&quot;);

            fetch isDelete, options[&quot;delete&quot;];
        }

        if !is_resource(file) {
            throw new Exception([&quot;Could not read file to send: %s&quot;,  filename]);
        }

        if empty options[&quot;inline&quot;] {
            let disposition = &quot;attachment&quot;;
        } else {
            let disposition = &quot;inline&quot;;
        }

        if empty options[&quot;resumable&quot;] {
            this-&gt;headers-&gt;set(&quot;Content-Length&quot;, size);
        } else {
            // Calculate byte range to download.
            let range = this-&gt;getByteRange(size),
                start = range[0],
                end = range[1];

            // HTTP/1.1 416 Requested Range Not Satisfiable
            if this-&gt;status == 416 {                
                header(sprintf(&quot;%s %d %s&quot;, this-&gt;getProtocolVersion(), this-&gt;status, this-&gt;getMessage(this-&gt;status)));
                exit();
            }

            // Partial Content
            if start &gt; 0 || end &lt; size - 1 {
                let this-&gt;status = 206;
            }

            // Range of bytes being sent
            this-&gt;headers-&gt;set(&quot;Accept-Ranges&quot;, &quot;bytes&quot;);
            this-&gt;headers-&gt;set(&quot;Content-Range&quot;, &quot;bytes &quot;.start.&quot;-&quot;.end.&quot;/&quot;.size);
            this-&gt;headers-&gt;set(&quot;Content-Length&quot;, end - start + 1);
        }

        // Set the headers for a download
        this-&gt;headers-&gt;set(&quot;Content-Disposition&quot;, disposition.&quot;; filename=\&quot;&quot;.filename.&quot;\&quot;&quot;);
        this-&gt;headers-&gt;set(&quot;Content-Type&quot;, mime);

        // Send all headers now
        this-&gt;headers-&gt;send();

        while ob_get_level() {
            // Flush all output buffers
            ob_end_flush();
        }

        // Manually stop execution
        ignore_user_abort(true);

        if empty options[&quot;timeout&quot;] {
            // Keep the script running forever
            set_time_limit(0);
        } else {
            set_time_limit((int)options[&quot;timeout&quot;]);
        }

        // Send data in 16kb blocks
        let block = 1024 * 16;

        if !empty options[&quot;sleep&quot;] {
            let speed = ((int)options[&quot;sleep&quot;]) * 1000;
        } else {
            let speed = 0;
        }

        fseek(file, start);

        while !feof(file)  {
            let pos = ftell(file);

            if pos &gt; end || connection_aborted() {
                break;
            }

            if pos + block &gt; end {
                // Don&apos;t read past the buffer.
                let block = end - pos + 1;
            }

            // Output a block of the file
            echo fread(file, block);

            // Send the data now
            flush();

            if speed &gt; 0 {
                usleep(speed);
            }
        }

        // Close the file
        fclose(file);

        if isDelete {
            try {
                // Attempt to remove the file
                unlink(filepath);
            } catch \Exception {
                // TODO: Write log for this exception
                // Do NOT display the exception, it will corrupt the output!
            }
        }

        // Stop execution
        exit();
    }

    /**
     * Redirect to some location.
     * This method prepares the response object to return an HTTP Redirect response to the client.
     *
     * @param string location The redirect destination
     * @param int status The redirect HTTP status code
     * @return object Response
     */
    public function redirect(string location = null, int status = 302, boolean external = false)
    {
        var url, di = Di::$fetch();;
        int redirects;

        this-&gt;setStatus(status);

        if !external {
            let url = di-&gt;get(&quot;url&quot;),
                location = url-&gt;get(location);
        }

        if di-&gt;has(&quot;session&quot;) &amp;&amp; this-&gt;loops {
            var session = di-&gt;get(&quot;session&quot;);

            let redirects = (int) session-&gt;get(&quot;_redirects&quot;, 0) + 1,
                this-&gt;redirects = redirects;

            session-&gt;set(&quot;_redirects&quot;, redirects);

            if this-&gt;redirects &gt; this-&gt;loops {
                return this;
            }
        }

        this-&gt;headers-&gt;set(&quot;Location&quot;, location);

        return this;
    }

    /**
     * Check whether status is for Empty.
     *
     * @return boolean
     */
    public function isEmpty() -&gt; boolean
    {
        return in_array(this-&gt;status, [201, 204, 304]);
    }

    /**
     * Check whether status is for Informational.
     *
     * @return boolean
     */
    public function isInformational() -&gt; boolean
    {
        return this-&gt;status &gt;= 100 &amp;&amp; this-&gt;status &lt; 200;
    }

    /**
     * Check whether status is for OK.
     *
     * @return boolean
     */
    public function isOk() -&gt; boolean
    {
        return this-&gt;status === 200;
    }

    /**
     * Check whether status is for Successful.
     *
     * @return boolean
     */
    public function isSuccessful() -&gt; boolean
    {
        return this-&gt;status &gt;= 200 &amp;&amp; this-&gt;status &lt; 300;
    }

    /**
     * Check whether status is for Redirect.
     *
     * @return boolean
     */
    public function isRedirect() -&gt; boolean
    {
        return in_array(this-&gt;status, [301, 302, 303, 307]);
    }

    /**
     * Check whether status is for Redirection.
     *
     * @return boolean
     */
    public function isRedirection() -&gt; boolean
    {
        return this-&gt;status &gt;= 300 &amp;&amp; this-&gt;status &lt; 400;
    }

    /**
     * Check whether status is for Forbidden.
     *
     * @return boolean
     */
    public function isForbidden() -&gt; boolean
    {
        return this-&gt;status === 403;
    }

    /**
     * Check whether status is for Not Found.
     *
     * @return boolean
     */
    public function isNotFound() -&gt; boolean
    {
        return this-&gt;status === 404;
    }

    /**
     * Check whether status is for Client error.
     *
     * @return boolean
     */
    public function isClientError() -&gt; boolean
    {
        return this-&gt;status &gt;= 400 &amp;&amp; this-&gt;status &lt; 500;
    }

    /**
     * Check whether status is for Server Error.
     *
     * @return boolean
     */
    public function isServerError() -&gt; boolean
    {
        return this-&gt;status &gt;= 500 &amp;&amp; this-&gt;status &lt; 600;
    }

    /**
     * Get message for Response codes.
     *
     * @param int code Status code
     * @return string
     */
    public function getMessage(int code = 200) -&gt; string
    {
        var message;

        fetch message, this-&gt;getMessages()[code];

        return message ? message : &quot;&quot;;
    }

    /**
     * Get all messages.
     *
     * @return array
     */
    public function getMessages() -&gt; array
    {
        return [
            //Informational 1xx
            100: &quot;Continue&quot;,
            101: &quot;Switching Protocols&quot;,
            102: &quot;Processing&quot;,
            //Successful 2xx
            200: &quot;OK&quot;,
            201: &quot;Created&quot;,
            202: &quot;Accepted&quot;,
            203: &quot;Non-Authoritative Information&quot;,
            204: &quot;No Content&quot;,
            205: &quot;Reset Content&quot;,
            206: &quot;Partial Content&quot;,
            207: &quot;Multi-Status&quot;,
            208: &quot;Already Reported&quot;,
            226: &quot;IM Used&quot;,
            //Redirection 3xx
            300: &quot;Multiple Choices&quot;,
            301: &quot;Moved Permanently&quot;,
            302: &quot;Found&quot;,
            303: &quot;See Other&quot;,
            304: &quot;Not Modified&quot;,
            305: &quot;Use Proxy&quot;,
            306: &quot;(Unused)&quot;,
            307: &quot;Temporary Redirect&quot;,
            308: &quot;Permanent Redirect&quot;,
            310: &quot;Too Many Redirects&quot;,
            //Client Error 4xx
            400: &quot;Bad Request&quot;,
            401: &quot;Unauthorized&quot;,
            402: &quot;Payment Required&quot;,
            403: &quot;Forbidden&quot;,
            404: &quot;Not Found&quot;,
            405: &quot;Method Not Allowed&quot;,
            406: &quot;Not Acceptable&quot;,
            407: &quot;Proxy Authentication Required&quot;,
            408: &quot;Request Timeout&quot;,
            409: &quot;Conflict&quot;,
            410: &quot;Gone&quot;,
            411: &quot;Length Required&quot;,
            412: &quot;Precondition Failed&quot;,
            413: &quot;Request Entity Too Large&quot;,
            414: &quot;Request-URI Too Long&quot;,
            415: &quot;Unsupported Media Type&quot;,
            416: &quot;Requested Range Not Satisfiable&quot;,
            417: &quot;Expectation Failed&quot;,
            418: &quot;I&apos;m a teapot&quot;,
            422: &quot;Unprocessable Entity&quot;,
            423: &quot;Locked&quot;,
            424: &quot;Failed Dependency&quot;,
            426: &quot;Upgrade Required&quot;,
            428: &quot;Precondition Required&quot;,
            429: &quot;Too Many Requests&quot;,
            431: &quot;Request Header Fields Too Large&quot;,
            //Server Error 5xx
            500: &quot;Internal Server Error&quot;,
            501: &quot;Not Implemented&quot;,
            502: &quot;Bad Gateway&quot;,
            503: &quot;Service Unavailable&quot;,
            504: &quot;Gateway Timeout&quot;,
            505: &quot;HTTP Version Not Supported&quot;,
            506: &quot;Variant Also Negotiates&quot;,
            507: &quot;Insufficient Storage&quot;,
            508: &quot;Loop Detected&quot;,
            510: &quot;Not Extended&quot;,
            511: &quot;Network Authentication Required&quot;
        ];
    }

    /**
     * Response data to JSON string.
     *
     * @param mixed data Can be any type excepta resource
     * @param int option The options for json_encode
     * @return object Response
     */
    public function toJson(var data, var option = null)
    {
        this-&gt;headers-&gt;set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);

        let this-&gt;body = json_encode(data, option);

        return this;
    }

    /**
     * Response data to XML string.
     *
     * &lt;pre&gt;&lt;code&gt;
     *     $response-&gt;toXml(
     *         [[&apos;title&apos; =&gt; &apos;hello world&apos;, &apos;desc&apos; =&gt; &apos;dont panic&apos;]],
     *         [&apos;root&apos; =&gt; &apos;blogs&apos;, &apos;namespace&apos; =&gt; &apos;http://example.com/xml/blog&apos;]
     *     );
     *
     *     // This will output the xml
     *     &lt;?xml version=&quot;1.0&quot;?&gt;&lt;blogs xmlns=&quot;http://example.com/xml/blog&quot;&gt;
     *     &lt;blog&gt;&lt;title&gt;hello world&lt;/title&gt;&lt;desc&gt;dont panic&lt;/desc&gt;&lt;/blog&gt;&lt;/blogs&gt;
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param mixed data Can be any type excepta resource
     * @param array options The options can be [root|charset|namespace]
     * @return object Response
     */
    public function toXml(var data, var options = null)
    {
        var doc, ns, rootName, charset;

        let rootName = isset options[&quot;root&quot;] ? options[&quot;root&quot;] : &quot;result&quot;,
            charset = isset options[&quot;charset&quot;] ? options[&quot;charset&quot;] : &quot;utf-8&quot;,
            doc = this-&gt;xmlEncode(data, rootName),
            doc-&gt;preserveWhiteSpace = false,
            doc-&gt;formatOutput = true,
            doc-&gt;encoding = charset;

        if fetch ns, options[&quot;namespace&quot;] {
            doc-&gt;createAttributeNS(ns, &quot;xmlns&quot;);
        }

        this-&gt;headers-&gt;set(&quot;Content-Type&quot;, &quot;application/xml;charset=&quot; . charset);

        let this-&gt;body = doc-&gt;saveXML();

        return this;
    }

    /**
     * Convert data to XML string.
     *
     * @param mixed data Can be any type excepta resource
     * @param string root The root tag name
     * @param DOMElement domNode null, ONLY FOR INTERNAL USE
     * @return DOMDocument domDoc object
     */
    public function xmlEncode(var data, string root = &quot;root&quot;, &lt;\DOMElement&gt; domNode = null)
    {
        var domDoc, type, key, val, node;

        if domNode === null {
            let domDoc = new \DOMDocument,
                domNode = domDoc-&gt;createElement(root);

            domDoc-&gt;appendChild(domNode);
            this-&gt;xmlEncode(data, null, domNode);

            return domDoc;
        }

        let domDoc = domNode-&gt;ownerDocument,
            type = typeof data;

        if type == &quot;array&quot; {
            for key, val in data {
                if typeof key == &quot;integer&quot; {
                    let node = domDoc-&gt;createElement(rtrim(domNode-&gt;tagName, &quot;s&quot;));
                    node-&gt;setAttribute(&quot;i&quot;, key);
                } else {
                    let node = domDoc-&gt;createElement(key);
                }
                domNode-&gt;appendChild(node);

                this-&gt;xmlEncode(val, null, node);
            }
        } elseif type == &quot;object&quot; {
            // set internal attr __is__ eq object
            domNode-&gt;setAttribute(&quot;__is__&quot;, &quot;obj&quot;);

            for key, val in get_object_vars(data) {
                if typeof val == &quot;array&quot; || typeof val == &quot;object&quot; {
                    let node = domDoc-&gt;createElement(key);
                    domNode-&gt;appendChild(node);
                    this-&gt;xmlEncode(val, null, node);
                } else {
                    domNode-&gt;setAttribute(key, val);
                }
            }
        } else {
            if type == &quot;boolean&quot; {
                let data = data ? &quot;true&quot; : &quot;false&quot;;
            }
            domNode-&gt;appendChild(domDoc-&gt;createTextNode(data));
        }
    }

    /**
     * Magic toString, convert response to string.
     *
     * @return string
     */
    public function __toString() -&gt; string
    {
        return (string) this-&gt;body;
    }

    /**
     *
     * At the moment we only support single ranges.
     * Multiple ranges requires some more work to ensure it works correctly
     * and comply with the spesifications:
     *    http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.2
     *
     * Multirange support annouces itself with:
     * header(&apos;Accept-Ranges: bytes&apos;);
     *
     * Multirange content must be sent with multipart/byteranges mediatype,
     * as well as a boundry header to indicate the various chunks of data.
     *
     * @return array The bytes range start and end, error message if there is
     */
    protected function getByteRange(int size) -&gt; array
    {
        var start, end, range;

        let start = 0,
            end = size - 1;

        // Defaults to start with when the HTTP_RANGE header doesn&apos;t exist.
        if isset _SERVER[&quot;HTTP_RANGE&quot;] {
            let range = explode(&quot;=&quot;, _SERVER[&quot;HTTP_RANGE&quot;], 2);

            if range[0] != &quot;bytes&quot; {
                let this-&gt;status = 416;
            } else {
                // multiple ranges could be specified at the same time,
                // but for simplicity only serve the first range ATM
                let range = explode(&quot;,&quot;, range[1], 2), range = range[0];

                // A negative value means we start from the end
                if range[0] == &quot;-&quot; {
                    let start = abs(size - abs((int)range));
                } else {
                    let range = explode(&quot;-&quot;, range), start = abs((int)range[0]);

                    if range[1] &amp;&amp; is_numeric(range[1]) {
                        let end = (int)range[1];
                    }
                }

                if end &gt; size {
                    let end = size - 1;
                }

                if start &gt; end || start &gt; size - 1 || end &gt;= size {
                    let this-&gt;status = 416;
                }
            }
        }
        return [start, end];
    }
}
</code></pre>                    </div>
                </div>
            </div>
        </div>

        <script src="../../../asset/static/js/jquery.min.js"></script>
        <script src="../../../asset/static/js/bootstrap.min.js"></script>
        <script src="../../../asset/static/js/highlight.pack.js"></script>
        <script src="../../../asset/static/js/jquery.slimscroll.min.js"></script>
        <script src="../../../asset/api_definition.js"></script>

        <script>var ZepCurrentPath = '../../../'</script>
        <script src="../../../asset/static/js/script.js"></script>
        <script type="text/javascript">
            $(window).on("load resize", function() {
                $('#menu-wrapper').slimscroll({ height: $(window).height() - 100, size: '3px' });
            });
        </script>
        <script type="text/javascript">
            $(document).ready(function() { $('pre code').each(function(i, block) { hljs.highlightBlock(block); }); });
            if ($('.zephir-source-file').length) {
                $('link[id]').each(function(i, link) {
                    link.disabled = (link.id != 'tomorrow-night');
                });
            }
        </script>
            </body>
</html>